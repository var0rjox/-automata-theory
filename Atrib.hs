-- do not edit; automatically generated by UU_AG
module Atrib where

type Lista = [String]

fVerificar a t@(x:xs) | a `elem` t = True 
                      | otherwise = False 

recorrido t@(x:xs) (y:ys) = fVerificar y t && recorrido t ys 
recorrido [] (y:ys) = False 
recorrido t@(x:xs) [] = True 


fencontrar y t@(x:xs) | y `elem` t = [] 
                      | otherwise = y:[] 

captura t@(x:xs) (y:ys) = fencontrar y t ++ captura t ys 
captura [] (y:ys) = []
captura t@(x:xs) [] = [] 

-- Cunatas variables son declaradas contar: 

-- Decl --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      con                  : Int
      d                    : Lista

-}
{-
   local variables for Decl.Dec:

-}
data Decl = Decl_Dec (String) (Tipo)
-- semantic domain
type T_Decl = ((Int),(Lista))
-- cata
sem_Decl :: (Decl) ->
            (T_Decl)
sem_Decl ((Decl_Dec (_string) (_tipo))) =
    (sem_Decl_Dec (_string) ((sem_Tipo (_tipo))))
sem_Decl_Dec :: (String) ->
                (T_Tipo) ->
                (T_Decl)
sem_Decl_Dec (_string) (_tipo) =
    let 
    in  (1,_string:[])
-- Decls -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      con                  : Int
      d                    : Lista

-}
{-
   local variables for Decls.De:

-}
{-
   local variables for Decls.Vacio:

-}
data Decls = Decls_De (Decl) (Decls)
           | Decls_Vacio 
-- semantic domain
type T_Decls = ((Int),(Lista))
-- cata
sem_Decls :: (Decls) ->
             (T_Decls)
sem_Decls ((Decls_De (_decl) (_decls))) =
    (sem_Decls_De ((sem_Decl (_decl))) ((sem_Decls (_decls))))
sem_Decls ((Decls_Vacio )) =
    (sem_Decls_Vacio )
sem_Decls_De :: (T_Decl) ->
                (T_Decls) ->
                (T_Decls)
sem_Decls_De (_decl) (_decls) =
    let ( _decl_con,_decl_d) =
            (_decl )
        ( _decls_con,_decls_d) =
            (_decls )
    in  (_decl_con + _decls_con,_decl_d ++ _decls_d)
sem_Decls_Vacio :: (T_Decls)
sem_Decls_Vacio  =
    let 
    in  (0,[])
-- Inst --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      u                    : Lista

-}
{-
   local variables for Inst.I1:

-}
{-
   local variables for Inst.I2:

-}
data Inst = Inst_I1 (String)
          | Inst_I2 (String)
-- semantic domain
type T_Inst = ((Lista))
-- cata
sem_Inst :: (Inst) ->
            (T_Inst)
sem_Inst ((Inst_I1 (_string))) =
    (sem_Inst_I1 (_string))
sem_Inst ((Inst_I2 (_string))) =
    (sem_Inst_I2 (_string))
sem_Inst_I1 :: (String) ->
               (T_Inst)
sem_Inst_I1 (_string) =
    let 
    in  (_string:[])
sem_Inst_I2 :: (String) ->
               (T_Inst)
sem_Inst_I2 (_string) =
    let 
    in  (_string:[])
-- Intrs -------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      u                    : Lista

-}
{-
   local variables for Intrs.Is1:

-}
{-
   local variables for Intrs.Is2:

-}
data Intrs = Intrs_Is1 (Inst) (Intrs)
           | Intrs_Is2 
-- semantic domain
type T_Intrs = ((Lista))
-- cata
sem_Intrs :: (Intrs) ->
             (T_Intrs)
sem_Intrs ((Intrs_Is1 (_inst) (_intrs))) =
    (sem_Intrs_Is1 ((sem_Inst (_inst))) ((sem_Intrs (_intrs))))
sem_Intrs ((Intrs_Is2 )) =
    (sem_Intrs_Is2 )
sem_Intrs_Is1 :: (T_Inst) ->
                 (T_Intrs) ->
                 (T_Intrs)
sem_Intrs_Is1 (_inst) (_intrs) =
    let ( _inst_u) =
            (_inst )
        ( _intrs_u) =
            (_intrs )
    in  (_inst_u ++ _intrs_u)
sem_Intrs_Is2 :: (T_Intrs)
sem_Intrs_Is2  =
    let 
    in  ([])
-- Prog --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:
      con                  : Int
      d                    : Lista
      r                    : Lista
      u                    : Lista

-}
{-
   local variables for Prog.P1:

-}
data Prog = Prog_P1 (String) (Decls) (Intrs)
-- semantic domain
type T_Prog = ((Int),(Lista),(Lista),(Lista))
-- cata
sem_Prog :: (Prog) ->
            (T_Prog)
sem_Prog ((Prog_P1 (_string) (_decls) (_intrs))) =
    (sem_Prog_P1 (_string) ((sem_Decls (_decls))) ((sem_Intrs (_intrs))))
sem_Prog_P1 :: (String) ->
               (T_Decls) ->
               (T_Intrs) ->
               (T_Prog)
sem_Prog_P1 (_string) (_decls) (_intrs) =
    let ( _decls_con,_decls_d) =
            (_decls )
        ( _intrs_u) =
            (_intrs )
    in  (_decls_con,_decls_d,captura _decls_d _intrs_u,_intrs_u)
-- Tipo --------------------------------------------------------
{-
   inherited attributes:

   chained attributes:

   synthesised attributes:

-}
{-
   local variables for Tipo.T1:

-}
{-
   local variables for Tipo.T2:

-}
data Tipo = Tipo_T1 
          | Tipo_T2 
-- semantic domain
type T_Tipo = ()
-- cata
sem_Tipo :: (Tipo) ->
            (T_Tipo)
sem_Tipo ((Tipo_T1 )) =
    (sem_Tipo_T1 )
sem_Tipo ((Tipo_T2 )) =
    (sem_Tipo_T2 )
sem_Tipo_T1 :: (T_Tipo)
sem_Tipo_T1  =
    let 
    in  ()
sem_Tipo_T2 :: (T_Tipo)
sem_Tipo_T2  =
    let 
    in  ()

